/**
 * @licence ActiveRecord for AngularJS
 * (c) 2013-2014 Bob Fanger, Jeremy Ashkenas, DocumentCloud
 * License: MIT
 */
angular.module("ActiveRecord", []).factory("ActiveRecord", ["$http", "$q", "$parse", "$injector", "translateFilter", function($http, $q, $parse, $injector, translateFilter) {
  "use strict";

  /**
   * If the value of the named property is a function then invoke it; otherwise, return it.
   * @param {Object} object
   * @param {String} property
   * @ignore
   */
  var _result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return angular.isFunction(value) ? value.call(object) : value;
  };

  var _lcfirst = function(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  };

  /**
   * Apply the filters to the properties.
   *
   * @param {Object|null} filters The $readFilters or $writeFilters.
   * @param {Object} properties
   * @ignore
   */
  var applyFilters = function(filters, properties) {
    if (filters) {
      angular.forEach(filters, function(filter, path) {
        var expression = $parse(path);
        var value = expression(properties);
        if (angular.isDefined(value)) {
          var newValue = (angular.isFunction(filter)) ? filter(value) : $parse(path + "|" + filter)(properties);
          expression.assign(properties, newValue);
        }
      });
    }
  };

  var getPolymorphicModelType = function(ModelType, type) {
    try { return $injector.get(type.replace("::", "")); } catch (err) { return ModelType; }
  };

  var checkPolymorphic = function(ModelType, item, options) {
    if (_.get(options, "polymorphic") && _.get(item, "type")) {
      return getPolymorphicModelType(ModelType, item.type);
    } else {
      return ModelType;
    }
  };

  /**
   * @class ActiveRecord  ActiveRecord for AngularJS
   * @constructor
   * @param {Object} [properties]  Initialize the record with these property values.
   * @param {Object} [options]
   */
  var ActiveRecord = function ActiveRecord(_properties, _options) {
    this.$initialize.apply(this, arguments);
  };
  ActiveRecord.prototype = {

    /**
     * @property {String} $idAttribute  The default name for the JSON id attribute is "id".
     */
    $idAttribute: "id",

    /**
     * @property {String} $urlRoot  Used by $url to generate URLs based on the model id. "[urlRoot]/id"
     */
    $urlRoot: null,

    $nullValues: [null, undefined],

    $attrToIgnore: [],

    $emptyValues: function() { return [""].concat(this.$nullValues); },

    /**
     * Constructor logic
     * (which is called by the autogenerated constructor via ActiveRecord.extend)
     * @param {Object} [properties]  Initialize the record with these property values.
     * @param {Object} [options]
     */
    $initialize: function(properties, options) {
      options = options || {};
      var defaults = _result(this, "$defaults");
      if (defaults) {
        angular.extend(this, defaults);
      }
      if (properties) {
        if (options.parse) {
          properties = this.$parse(properties);
        }
        if (options.readFilters) {
          applyFilters(_result(this, "$readFilters"), properties);
        }
        angular.extend(this, properties);
      }

      var model = angular.copy(this);
      this.$previousAttributes = function() {
        return model;
      };

      if (options.url) {
        this.$url = options.url;
      }
      if (options.urlRoot) {
        this.$urlRoot = options.urlRoot;
      }

      this.$errors = {};
    },

    $hasAttributes: function(attrs) {
      var model = this;
      var isValid = true;
      angular.forEach(attrs, function(v, k) {
        if (model[k] !== v && !angular.isFunction(v)) {
          isValid = false;
        }
      });
      return isValid;
    },

    $getAttributes: function() {
      var model = this;
      var object = {};
      angular.forEach(model.$attributes, function(v) {
        object[v] = model[v];
      });
      return object;
    },

    /**
     * Determine if the model has changed since the last sync (fetch/load).
     *
     * @param {String} [property] Determine if that specific property has changed.
     * @returns {Boolean}
     */
    $hasChanged: function(property) {
      var changed = this.$changedAttributes();
      if (property) {
        return property in changed;
      }
      if (_.keys(changed).length) {
        return true;
      }
      return false;
    },

    $filteredByAssociations: function(attr) {
      var filtered = false;
      attr = attr.toLowerCase();
      angular.forEach(this.$associations, function(assoc, key) {
        var pluralName;
        if ($injector.has(key)) {
          var AssocModel = $injector.get(key);
          pluralName = AssocModel.prototype.$plural.toLowerCase();
        }
        var lKey = key.toLowerCase();
        if (attr == lKey || attr == pluralName || (assoc.options.through && assoc.options.through.toLowerCase() == lKey)) {
          filtered = !assoc.options.parentManaged;
          return;
        }
      });
      return filtered;
    },

    /**
     * Return an object containing all the properties that have changed.
     * Removed properties will be set to undefined.
     *
     * @param {Object} [diff] An object to diff against, determining if there would be a change.
     * @returns {Object}
     */
    $changedAttributes: function(diff) {
      var current = diff || this; // By default diff against the current values
      var changed = {};
      var previousAttributes = this.$previousAttributes();
      var property;

      if (!diff) { // Skip removed properties (only compare the properties in the diff object)
        for (property in previousAttributes) {
          if (property[0] === "$" || typeof previousAttributes[property] === "function") continue;
          if (this.$attrToIgnore.indexOf(property) >= 0) continue;
          if (typeof current[property] === "undefined" && typeof previousAttributes[property] !== "undefined") {
            changed[property] = current[property];
          }
        }
      }

      for (property in current) {
        if (this.$attrToIgnore.indexOf(property) >= 0) continue;
        if (property[0] === "$" || typeof previousAttributes[property] === "function") continue;
        if (current.hasOwnProperty(property) && !this.$filteredByAssociations(property)) {
          var value = current[property];
          if (typeof value !== "function" && angular.equals(value, previousAttributes[property]) === false && (!this.$attributes || this.$attributes.indexOf(property) !== -1)) {
            changed[property] = value;
          }
        }
      }

      return changed;
    },

    /**
     * Get the previous value of a property.
     * @param {String} [property]
     */
    $previous: function(property) {
      var previousAttributes = this.$previousAttributes();
      if (property == null || !previousAttributes) {
        return null;
      }
      return previousAttributes[property];
    },

    /**
     * Get all of the properties of the model at the time of the previous sync (fetch/save).
     * @returns {Object}
     */
    $previousAttributes: function() {
      return {};
    },

    $toCamelCase: function(string) {
      var camelCase = string.replace(/(?:^|[-_])(\w)/g, function(_, c) {
        return c ? c.toUpperCase() : "";
      });
      return camelCase;
    },

    $computeData: function(data) {
      data = data || this;
      var model = this;
      angular.forEach(data, function(value, key) {
        var camelCaseKey = model.$toCamelCase(key);
        var lowerCaseKey = camelCaseKey.toLowerCase();
        var assocName = null;
        var module = null;
        angular.forEach(model.$associations, function(valueAssoc, keyAssoc) {
          var Assoc = null;
          if (!assocName) {
            if ($injector.has(keyAssoc)) {
              Assoc = $injector.get(keyAssoc);
            } else if (valueAssoc.options.model && $injector.has(valueAssoc.options.model)) {
              Assoc = $injector.get(valueAssoc.options.model);
            }

            if (lowerCaseKey == keyAssoc.toLowerCase()) {
              assocName = keyAssoc;
            } else if (lowerCaseKey == Assoc.prototype.$plural.toLowerCase()) {
              assocName = Assoc.prototype.$plural;
              module = keyAssoc;
            } else if (valueAssoc.options.through) {
              var Related = $injector.get(valueAssoc.options.through);
              var relName = Related.prototype.$plural || Related.prototype.$name || valueAssoc.options.through;
              if (lowerCaseKey == relName.toLowerCase()) {
                module = valueAssoc.options.through;
                assocName = relName;
              }
            }
            if (valueAssoc.options.model && assocName) {
              module = valueAssoc.options.model;
            }
          }
        });
        if (assocName) {
          if (!module) module = assocName;
          var lowerCamelCaseKey = _lcfirst(assocName);
          var type = model.$associations[assocName] ? model.$associations[assocName].type : model.$associations[module];
          model[lowerCamelCaseKey] = type == "belongsTo" ? undefined : [];
          var AssocModel = $injector.get(module);
          if (angular.isArray(value)) {
            angular.forEach(value, function(v) {
              var assocModel = new AssocModel();
              v = assocModel.$parse(v);
              assocModel.$computeData(v);
              model[lowerCamelCaseKey].push(assocModel);
            });
          } else if (value) {
            var assocModel = new AssocModel();
            value = assocModel.$parse(value);
            assocModel.$computeData(value);
            model[lowerCamelCaseKey] = assocModel;
          }
        } else {
          model[key] = value;
        }
      });
      data = angular.copy(model);
      model.$previousAttributes = function() {
        return data;
      };

      model.$validate();
      return model;
    },

    /**
     * (re)load data from the backend.
     * @param {Object} [options] sync options
     * @return $q.promise
     */
    $fetch: function(options) {
      var model = this;
      var deferred = $q.defer();
      this.$sync("read", this, options).then(function(response) {
        var data = model.$parse(response.data, options);
        if (angular.isObject(data)) {
          applyFilters(_result(model, "$readFilters"), data);
          model.$computeData(data);
          model.$validate();
          data = angular.copy(model);
          model.$previousAttributes = function() {
            return data;
          };
          deferred.resolve(model);
        } else {
          deferred.reject("Not a valid response type");
        }
      }, deferred.reject);
      return deferred.promise;
    },

    $validationErrorMessages: {},

    $validations: {},

    $fieldTranslations: {},

    $isValid: function(fieldName) {
      var valid = false;
      if (Object.keys(this.$errors).length === 0) {
        valid = true;
      } else if (fieldName && !this.$errors[fieldName]) {
        valid = true;
      }
      return valid;
    },

    $getErrorMessage: function(fieldName, functionName) {
      var validationValue = this.$validations[fieldName][functionName];
      var fieldValue = this[fieldName];
      var errorMessage = this.$validationErrorMessages.hasOwnProperty(functionName) ? this.$validationErrorMessages[functionName] : "is invalid";
      if (angular.isFunction(errorMessage)) errorMessage = errorMessage.call(this, fieldName, fieldValue, validationValue);
      if (typeof sprintf !== "undefined") {
        if (!errorMessage.errorMessage) {
          errorMessage = sprintf(errorMessage, { fieldName: translateFilter(this.$fieldTranslations[fieldName]) || fieldName, fieldValue: fieldValue, validationValue: validationValue });
        } else {
          errorMessage.fieldName = translateFilter(this.$fieldTranslations[fieldName]) || fieldName;
          errorMessage.fieldValue = fieldValue;
          errorMessage.validationValue = validationValue;
          errorMessage = sprintf(errorMessage.errorMessage, errorMessage);
        }
      }
      return errorMessage;
    },

    $applyValidation: function(fieldName, fieldValue, errors) {
      if (!errors) errors = [];
      var self = this;
      angular.forEach(this.$validations[fieldName], function(validationValue, functionName) {
        var reserved = ["notEmpty", "required", "triggers"];
        if (reserved.indexOf(functionName) == -1 && self[functionName]) {
          if (self[functionName](fieldValue, validationValue) !== true) {
            errors.push(self.$getErrorMessage(fieldName, functionName));
          }
        }
      });
      return errors;
    },

    $validateOne: function(fieldName, skipTriggers) {
      var errors = [];
      delete this.$errors[fieldName];
      if (this.$validations[fieldName]) {
        var self = this;
        var emptyError = true;
        if (self.hasOwnProperty(fieldName) && !_.includes(self.$emptyValues(), self[fieldName])) {
          var props = typeof self[fieldName] == "object" && !angular.isDate(self[fieldName]) ? self[fieldName] : [self[fieldName]];
          var notEmptyValidation = false;
          if (self.$validations[fieldName].notEmpty) {
            var notEmpty = self.$validations[fieldName].notEmpty;
            if (_.isFunction(notEmpty)) notEmpty = notEmpty.call(self);
            if (notEmpty !== true) {
              notEmptyValidation = notEmpty;
              emptyError = false;
            } else {
              notEmptyValidation = self.$emptyValues();
            }
          }
          if (self.$validations[fieldName].indexErrors) errors = {};
          angular.forEach(props, function(prop, index) {
            if (notEmptyValidation === false || notEmptyValidation.indexOf(prop) === -1) {
              emptyError = false;
              if (self.$validations[fieldName].indexErrors) {
                var err = self.$applyValidation(fieldName, prop, []);
                if (err.length) errors[index] = err;
              } else {
                errors = self.$applyValidation(fieldName, prop, errors);
              }
            }
          });
          if (emptyError && this.$validations[fieldName].notEmpty) {
            errors.push(self.$getErrorMessage(fieldName, "notEmpty"));
          }
        } else if (this.$validations[fieldName].required && (!_.isFunction(this.$validations[fieldName].required) || this.$validations[fieldName].required.call(this))) {
          var errMessage = null;
          if (angular.isObject(this.$validations[fieldName].required) && this.$validations[fieldName].required.message) {
            errMessage = this.$validations[fieldName].required.message;
          } else if (this.$validationErrorMessages.required) {
            errMessage = this.$validationErrorMessages.required;
          } else {
            errMessage = "is required";
          }
          if (angular.isFunction(errMessage)) errMessage = errMessage(fieldName);
          errors.push(errMessage);
        }

        if (_.isArray(this.$validations[fieldName].triggers) && !skipTriggers) {
          _.forEach(this.$validations[fieldName].triggers, function(tiggeredFieldName) { self.$validateOne(tiggeredFieldName, true); });
        }
      }
      var errorArray = angular.isArray(errors) ? errors : Object.keys(errors);
      if (errorArray.length) {
        this.$errors[fieldName] = errors;
      }
      return this.$isValid(fieldName);
    },

    $validate: function(fieldName) {
      if (fieldName) return this.$validateOne(fieldName);

      var self = this;
      this.$errors = {};
      angular.forEach(this.$validations, function(_validation, validationKey) {
        self.$validateOne(validationKey);
      });
      return this.$isValid();
    },

    $saveBelongsToAssociations: function(values, options, deferred) {
      var model = this;
      // we want to save associations before.. so we need some callback stuff
      var nbrLeft = 0;
      var nbrFound = 0;
      var err = false;
      var assocsaveCallbackContainer = function(assoc) {
        return function() {
          if (err) return;
          if (assoc.$isNew()) {
            err = true;
            return deferred.reject();
          }
          nbrLeft--;
          if (nbrLeft === 0) {
            model.$save(values, options).then(function(savedModel) {
              deferred.resolve(savedModel);
            }).catch(function(saveErr) {
              deferred.reject(saveErr);
            });
          }
        };
      };
      // get all associations data and save them if needed
      angular.forEach(this.$associations, function(assocObj, assocKey) {
        var keyName = assocKey;
        if (assocObj.options.singular) keyName = assocObj.options.singular;
        keyName = _lcfirst(keyName);
        var assoc = model["$" + keyName];
        if (assoc && assocObj.type == "belongsTo") {
          if (assoc.$isNew()) {
            nbrFound++;
            nbrLeft++;
            assoc.$save().then(
              assocsaveCallbackContainer(assoc)
            ).catch(function(error) {
              err = true;
              deferred.reject(error);
            });
          } else {
            model[assocObj.options.key] = assoc[assoc.$idAttribute];
          }
        }
      });

      return nbrFound;
    },

    $saveHasManyAssociations: function(deferred) {
      var model = this;
      var nbrLeft = 0;
      var nbrFound = 0;
      var err = false;

      var assocsaveCallbackContainer = function(assoc) {
        return function() {
          if (err) return;
          if (assoc.$isNew()) {
            err = true;
            return deferred.reject();
          }
          nbrLeft--;
          if (nbrLeft === 0) {
            deferred.resolve(model);
          }
        };
      };

      angular.forEach(this.$associations, function(assocObj, assocKey) {
        if (assocObj.options.parentManaged) return;
        var Related = $injector.get(assocObj.options.through || assocKey);
        var keyName = Related.prototype.$plural || Related.prototype.$name || assocObj.options.through;
        var parentManaged = !!assocObj.options.parentManaged;

        if (parentManaged) {
          // Modifications will be sent as a delta of the parent object and managed directly. No need to make any other calls
          return;
        }

        keyName = _lcfirst(keyName);
        var assocs = model[keyName];
        if (assocs && assocObj.type == "hasMany") {
          //delete assocs
          var oldAssoc = model.$previousAttributes()[keyName];
          if (oldAssoc && oldAssoc.length) {
            var ids = [];
            angular.forEach(assocs, function(obj) {
              ids.push(obj[obj.$idAttribute]);
            });
            var url = model.$url() + (Related.prototype.$urlRessource || assocKey);
            if (assocObj.options.batch) {
              var elements = [];
              angular.forEach(oldAssoc, function(obj) {
                if (ids.indexOf(obj[obj.$idAttribute]) === -1) {
                  elements.push(obj);
                }
              });
              if (elements.length) {
                nbrFound++;
                nbrLeft++;
                Related.destroyAll(elements, { url: url }).then(
                  assocsaveCallbackContainer()
                ).catch(function(_error) {
                  err = true;
                  // callback(false, error);
                });
              }
            } else {
              angular.forEach(oldAssoc, function(obj) {
                if (ids.indexOf(obj[obj.$idAttribute]) === -1) {
                  nbrFound++;
                  nbrLeft++;
                  obj.$destroy({ url: url + "/" + obj[obj.$idAttribute] }).then(
                    assocsaveCallbackContainer(obj)
                  ).catch(function(_error) {
                    err = true;
                    // callback(false, error);
                  });
                }
              });
            }
          }
          angular.forEach(assocs, function(assoc) {
            if (assoc.$isNew() || assoc.$hasChanged()) {
              nbrFound++;
              nbrLeft++;
              assoc[assoc.$associations[model.$name].options.key] = model[model.$idAttribute];
              assoc.$save().then(
                assocsaveCallbackContainer(assoc)
              ).catch(function(error) {
                err = true;
                deferred.reject(error);
              });
            }
          });
        }
      });

      return nbrFound;
    },

    /**
     * Save the record to the backend.
     * @param {Object} [values] Set these values before saving the record.
     * @param {Object} [options] sync options
     * @return $q.promise
     */
    $save: function(values, options) {
      if (values) {
        if (angular.isString(values)) {
          values = {};
          values[arguments[0]] = options;
          options = arguments[2];
        }
        angular.extend(this, values);
      }

      var model = this;
      var deferred = $q.defer();

      if (!model.$validate()) {
        deferred.reject(model.$errors);
        return deferred.promise;
      }

      //if we have found some associations not already saved, we need to wait for our callback to be called
      options = options || {};
      if (this.$saveBelongsToAssociations(values, options, deferred)) {
        return deferred.promise;
      }

      var data = this.$isNew() ? this : this.$changedAttributes();
      options.data = this.$serialize(data);

      var filters = _result(this, "$writeFilters");
      if (filters) {
        applyFilters(filters, options.data);
      }

      var operation = this.$isNew() ? "create" : "update";
      this.$sync(operation, this, options).then(function(response) {
        var parsedData = model.$parse(response.data, options);
        if (angular.isObject(parsedData)) {
          applyFilters(_result(model, "$readFilters"), parsedData);
          angular.extend(model, parsedData);
          parsedData = angular.copy(model);
          model.$previousAttributes = function() {
            return parsedData;
          };
          model.$computeData(parsedData);
        }
        if (!model.$saveHasManyAssociations(deferred)) deferred.resolve(model);
      }).catch(function(err) {
        deferred.reject(err);
      });
      return deferred.promise;
    },

    $serialize: function(data) {
      var self = this;
      var serialized = {};

      if (angular.isArray(data)) {
        serialized = _.map(data, function(value) {
          return self.$serialize(value);
        });
      } else if (angular.isObject(data)) {
        angular.forEach(data, function(value, key) {
          if (key[0] !== "$") {
            serialized[key] = self.$serialize(value);
          }
        });
      } else {
        serialized = data;
      }

      return angular.copy(serialized);
    },

    /**
     * Destroy this model on the server if it was already persisted.
     * @param {Object} [options] sync options
     * @return $q.promise
     */
    $destroy: function(options) {
      var deferred = $q.defer();
      if (this.$isNew()) {
        deferred.resolve();
        return deferred.promise;
      }
      this.$sync("delete", this, options).then(function() {
        deferred.resolve();
      }, deferred.reject);
      return deferred.promise;
    },

    /**
     * Generate the url for the $save, $fetch and $destroy methods.
     * @return {String} url
     */
    $url: function() {
      var urlRoot = _result(this, "$urlRoot");
      var urlRessource = _result(this, "$urlRessource");
      if (urlRessource) urlRoot += urlRessource;
      if (typeof this[this.$idAttribute] === "undefined") {
        return urlRoot;
      }
      if (urlRoot === null) {
        throw "Implement this.$url() or specify this.$urlRoot";
      }
      return urlRoot + (urlRoot.charAt(urlRoot.length - 1) === "/" ? "" : "/") + encodeURIComponent(this[this.$idAttribute]);
    },

    /**
     * Process the data from the response and return the record-properties.
     * @param {Object} data  The data from the sync response.
     * @param {Object} [options] sync options
     * @return {Object}
     */
    $parse: function(data, _options) {
      return data;
    },

    /**
     * Process the record-properties and return the data for the resquest. (counterpart of $parse)
     * Called automaticly by JSON.stringify: @link https://developer.mozilla.org/en-US/docs/JSON#toJSON()_method
     */
    toJSON: function() {
      return this;
    },

    /**
     * @property {Object} $readFilters
     * Preform post-processing on the properties after $parse() through angular filters.
     * These could be done in $parse(), but $readFilters enables a more reusable and declarative way.
     */
    $readFilters: null,

    /**
     * @property {Object} $writeFilters
     * Preform pre-processing on the properties before $save() through angular filters.
     * These could be done in toJSON(), but $readFilters enables a more reusable and declarative way.
     */
    $writeFilters: null,

    /**
     * A model is new if it lacks an id.
     */
    $isNew: function() {
      return this[this.$idAttribute] == null;
    },

    /**
     * By default calls ActiveRecord.sync
     * Override to change the backend implementation on a per model bases.
     * @param {String} operation  "create", "read", "update" or "delete"
     * @param {ActiveRecord} model
     * @param {Object} options
     * @return $q.promise
     */
    $sync: function(_operation, _model, _options) {
      return ActiveRecord.sync.apply(this, arguments);
    },

    $associations: {}
  };

  /**
   * Preform a CRUD operation on the backend.
   *
   * @static
   * @param {String} operation  "create", "read", "update" or "delete"
   * @param {ActiveRecord} model
   * @param {Object} options
   * @return $q.promise
   */
  ActiveRecord.sync = function(operation, model, options) {
    if (typeof options === "undefined") {
      options = {};
    }
    if (!options.method) {
      var crudMapping = {
        "create": "POST",
        "read": "GET",
        "update": "PUT",
        "delete": "DELETE",
        "patch": "PATCH"
      };
      options.method = crudMapping[operation];
    }
    if (!options.url) {
      options.url = _result(model, "$url");
      options.originalUrl = options.url;
    }
    if (options.filters) {
      var extensions = [];
      angular.forEach(options.filters, function(filter, key) {
        if (angular.isArray(filter)) {
          angular.forEach(filter, function(value) {
            extensions.push(key + "[]=" + value);
          });
        } else {
          extensions.push(key + "=" + filter);
        }
      });
      options.url = (options.originalUrl || options.url) + "?" + extensions.join("&");
    }
    return $http(options);
  };

  ActiveRecord.lastId = 0;

  /**
   * Create a subclass.
   * @static
   * @param {Object} protoProps
   * @param {Object} [staticProps]
   * @return {Function} Constructor
   */
  ActiveRecord.extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    if (protoProps && typeof protoProps.$constructor === "function") {
      child = protoProps.$constructor;
    } else {
      child = function() {
        this.$id = ++ActiveRecord.lastId;
        return parent.apply(this, arguments);
      };
    }
    angular.extend(child, parent, staticProps);
    var Surrogate = function() { this.$constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate();
    if (protoProps) {
      angular.extend(child.prototype, protoProps);
    }
    child.__super__ = parent.prototype;
    child.prototype.$associations = {};
    return child;
  };

  ActiveRecord.hasMany = function(entity, options) {
    if (!options) options = {};
    if ($injector.has(entity) && (!options.through || $injector.has(options.through))) {
      var Related = $injector.get(options.through || entity);
      var isThrough = !!options.through;
      var parentManaged = !!options.parentManaged;
      var relatedName = _lcfirst(Related.prototype.$plural || Related.prototype.$name || options.through);

      this.prototype.$associations[entity] = { type: "hasMany", options: options };

      this.prototype["add" + entity] = function(model, relatedData) {
        if (!parentManaged && model.$isNew()) return "can't be new";
        if (!relatedData) relatedData = {};
        var newEntity = null;
        if (isThrough) {
          newEntity = new Related(relatedData);
          newEntity["add" + entity](model);
        } else {
          newEntity = model;
        }
        if (!this[relatedName]) this[relatedName] = [];
        this[relatedName].push(newEntity);
        return this;
      };

      this.prototype["remove" + entity] = function(model, relatedData) {
        if (!relatedData) relatedData = {};
        var oldEntity = null;
        if (isThrough) {
          oldEntity = new Related(relatedData);
          oldEntity["remove" + entity](model);
        } else {
          oldEntity = model;
        }
        if (!this[relatedName]) this[relatedName] = [];
        if (!this[relatedName + "ToRemove"]) this[relatedName + "ToRemove"] = [];

        var index = _.findIndex(this[relatedName], function(relatedEntity) {
          if (relatedEntity === oldEntity) {
            // Same object
            return true;
          } else if (relatedEntity[relatedEntity.$idAttribute] && oldEntity[relatedEntity.$idAttribute] && relatedEntity[relatedEntity.$idAttribute] == oldEntity[relatedEntity.$idAttribute]) {
            // Standard says all entities have a unique attribute id (assuming they are the same type)
            return true;
          } else if (relatedEntity.$id && oldEntity.$id && relatedEntity.$id == oldEntity.$id) {
            // Not the same objet, but a copy of the same object, for new objets that don't have an id yet
            return true;
          }
          return false;
        });

        if (index == -1) {
          return "model not found";
        }

        this[relatedName + "ToRemove"].push(this[relatedName].splice(index, 1)[0]);
        return this;
      };
    }
  };

  ActiveRecord.belongsTo = function(entity, options) {
    if (!options) options = {};

    if ($injector.has(entity) || (options.model && $injector.has(options.model))) {
      var name = _lcfirst(entity);
      this.prototype.$associations[entity] = { type: "belongsTo", options: angular.copy(options) };
      this.prototype["add" + entity] = function(model) {
        if (model.$isNew()) return "can't be new";
        var relatedKey = this.$associations[entity].options.key;
        this[name] = model;
        this[relatedKey] = model[model.$idAttribute];
        return model;
      };
    }
  };

  /**
   * Load a single record.
   *
   * @static
   * @param {Mixed} id
   * @param {Object} [options]
   * @return $q.promise
   */
  ActiveRecord.fetchOne = function(id, options) {
    var model = new this();
    model[model.$idAttribute] = id;
    return model.$fetch(options);
  };

  ActiveRecord.destroyAll = function(models, options) {
    if (typeof options === "undefined") {
      options = {};
    }
    options.filters = { ids: [] };
    angular.forEach(models, function(model) {
      if (model[model.$idAttribute]) options.filters.ids.push(model[model.$idAttribute]);
    });
    options.method = "DELETE";
    if (!options.url) options.url = _result(this.prototype, "$url");
    return ActiveRecord.sync(null, null, options);
  };

  /**
   * Load a collection of records.
   *
   * @static
   * @param {Object} [options]
   * @return $q.promise
   */
  ActiveRecord.fetchAll = function(options) {
    var ModelType = this;
    var model = new ModelType();
    var deferred = $q.defer();
    model.$sync("read", model, options).then(function(response) {
      var data = model.$parse(response.data, options);
      var filters = ModelType.prototype.$readFilters;
      var models = [];
      if (angular.isArray(data)) {
        angular.forEach(data, function(item) {
          ModelType = checkPolymorphic(ModelType, item, options);
          applyFilters(filters, item);
          var newModel = new ModelType();
          newModel.$computeData(item);
          newModel.$validate();
          models.push(newModel);
        });
        deferred.resolve(models);
      } else if (data && data.meta && data.data && angular.isArray(data.data)) {
        // This code has been added to allow for paginated results with a total count
        angular.forEach(data.data, function(item) {
          ModelType = checkPolymorphic(ModelType, item, options);
          applyFilters(filters, item);
          var newModel = new ModelType();
          newModel.$computeData(item);
          models.push(newModel);
        });
        data.meta.models = models;
        deferred.resolve(data.meta);
      } else {
        deferred.reject("Not a valid response, expecting an array");
      }
    }, deferred.reject);
    return deferred.promise;
  };
  return ActiveRecord;
}]);
